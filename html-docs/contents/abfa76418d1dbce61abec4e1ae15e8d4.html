<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>SwitchPoint</title>
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,300italic,400italic,700italic|Source+Code+Pro:300,400,700' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="../assets/css/bootstrap.css">
<link rel="stylesheet" href="../assets/css/jquery.bonsai.css">
<link rel="stylesheet" href="../assets/css/main.css">
<link rel="stylesheet" href="../assets/icon-font/icons.css">
<script type="text/javascript" src="../assets/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript" src="../assets/js/bootstrap.js"></script>
<script type="text/javascript" src="../assets/js/jquery.bonsai.js"></script>

  </head>
  <body>
    <div>

      <!-- Name Title -->

      <h1>SwitchPoint</h1>

      <!-- Type and Stereotype -->

      <section style="margin-top: .5em;">
        <span class="alert alert-info">
          <span class="node-icon staruml-icon icon-UMLClass"></span>
          UMLClass
        </span>
        
      </section>

      <!-- Path -->

      <section style="margin-top: 10px">
        
        
        
          
          <span class="label label-info"><a href='cf9c8b720f3815adeccaf3ef6e48c6c4.html'><span class='node-icon staruml-icon icon-Project'></span>UML</a></span>
        
          <span>::</span>
          <span class="label label-info"><a href='da2be80fe6e48fd9d101c1429f49bd58.html'><span class='node-icon staruml-icon icon-UMLModel'></span>openJDK</a></span>
        
          <span>::</span>
          <span class="label label-info"><a href='ee78c922cc529ca62752f771c0bb7b9d.html'><span class='node-icon staruml-icon icon-UMLPackage'></span>java</a></span>
        
          <span>::</span>
          <span class="label label-info"><a href='a93b2fc56794e246bf26838d14b54f65.html'><span class='node-icon staruml-icon icon-UMLPackage'></span>lang</a></span>
        
          <span>::</span>
          <span class="label label-info"><a href='e4c701803145d5e3dc249c369d7c56bb.html'><span class='node-icon staruml-icon icon-UMLPackage'></span>invoke</a></span>
        
          <span>::</span>
          <span class="label label-info"><a href='abfa76418d1dbce61abec4e1ae15e8d4.html'><span class='node-icon staruml-icon icon-UMLClass'></span>SwitchPoint</a></span>
        
      </section>

      <!-- Diagram -->

      

      <!-- Description -->

      
      <section>
        <h3>Description</h3>
        <div>
          
            <p>Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
This code is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License version 2 only, as
published by the Free Software Foundation.  Oracle designates this
particular file as subject to the &quot;Classpath&quot; exception as provided
by Oracle in the LICENSE file that accompanied this code.
This code is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
version 2 for more details (a copy is included in the LICENSE file that
accompanied this code).
You should have received a copy of the GNU General Public License version
2 along with this work; if not, write to the Free Software Foundation,
Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
or visit www.oracle.com if you need additional information or have any
questions.
&lt;p&gt;
A {@code SwitchPoint} is an object which can publish state transitions to other threads.
A switch point is initially in the &lt;em&gt;valid&lt;/em&gt; state, but may at any time be
changed to the &lt;em&gt;invalid&lt;/em&gt; state.  Invalidation cannot be reversed.
A switch point can combine a &lt;em&gt;guarded pair&lt;/em&gt; of method handles into a
&lt;em&gt;guarded delegator&lt;/em&gt;.
The guarded delegator is a method handle which delegates to one of the old method handles.
The state of the switch point determines which of the two gets the delegation.
&lt;p&gt;
A single switch point may be used to control any number of method handles.
(Indirectly, therefore, it can control any number of call sites.)
This is done by using the single switch point as a factory for combining
any number of guarded method handle pairs into guarded delegators.
&lt;p&gt;
When a guarded delegator is created from a guarded pair, the pair
is wrapped in a new method handle {@code M},
which is permanently associated with the switch point that created it.
Each pair consists of a target {@code T} and a fallback {@code F}.
While the switch point is valid, invocations to {@code M} are delegated to {@code T}.
After it is invalidated, invocations are delegated to {@code F}.
&lt;p&gt;
Invalidation is global and immediate, as if the switch point contained a
volatile boolean variable consulted on every call to {@code M}.
The invalidation is also permanent, which means the switch point
can change state only once.
The switch point will always delegate to {@code F} after being invalidated.
At that point {@code guardWithTest} may ignore {@code T} and return {@code F}.
&lt;p&gt;
Here is an example of a switch point in action:
&lt;pre&gt;{@code
MethodHandle MH<em>strcat = MethodHandles.lookup()
.findVirtual(String.class, &quot;concat&quot;, MethodType.methodType(String.class, String.class));
SwitchPoint spt = new SwitchPoint();
assert(!spt.hasBeenInvalidated());
// the following steps may be repeated to re-use the same switch point:
MethodHandle worker1 = MH</em>strcat;
MethodHandle worker2 = MethodHandles.permuteArguments(MH<em>strcat, MH</em>strcat.type(), 1, 0);
MethodHandle worker = spt.guardWithTest(worker1, worker2);
assertEquals(&quot;method&quot;, (String) worker.invokeExact(&quot;met&quot;, &quot;hod&quot;));
SwitchPoint.invalidateAll(new SwitchPoint[]{ spt });
assert(spt.hasBeenInvalidated());
assertEquals(&quot;hodmet&quot;, (String) worker.invokeExact(&quot;met&quot;, &quot;hod&quot;));
}&lt;/pre&gt;
&lt;p style=&quot;font-size:smaller;&quot;&gt;
&lt;em&gt;Discussion:&lt;/em&gt;
Switch points are useful without subclassing.  They may also be subclassed.
This may be useful in order to associate application-specific invalidation logic
with the switch point.
Notice that there is no permanent association between a switch point and
the method handles it produces and consumes.
The garbage collector may collect method handles produced or consumed
by a switch point independently of the lifetime of the switch point itself.
&lt;p style=&quot;font-size:smaller;&quot;&gt;
&lt;em&gt;Implementation Note:&lt;/em&gt;
A switch point behaves as if implemented on top of {@link MutableCallSite},
approximately as follows:
&lt;pre&gt;{@code
public class SwitchPoint {
private static final MethodHandle
K<em>true  = MethodHandles.constant(boolean.class, true),
K</em>false = MethodHandles.constant(boolean.class, false);
private final MutableCallSite mcs;
private final MethodHandle mcsInvoker;
public SwitchPoint() {
this.mcs = new MutableCallSite(K<em>true);
this.mcsInvoker = mcs.dynamicInvoker();
}
public MethodHandle guardWithTest(
MethodHandle target, MethodHandle fallback) {
// Note:  mcsInvoker is of type ()boolean.
// Target and fallback may take any arguments, but must have the same type.
return MethodHandles.guardWithTest(this.mcsInvoker, target, fallback);
}
public static void invalidateAll(SwitchPoint[] spts) {
List&lt;MutableCallSite&gt; mcss = new ArrayList&lt;&gt;();
for (SwitchPoint spt : spts)  mcss.add(spt.mcs);
for (MutableCallSite mcs : mcss)  mcs.setTarget(K</em>false);
MutableCallSite.syncAll(mcss.toArray(new MutableCallSite[0]));
}
}
}&lt;/pre&gt;
@author Remi Forax, JSR 292 EG
@since 1.7</p>
          
        </div>
      </section>
      

      <!-- Specification -->

      

      <!-- Directed Relationship -->

      

      <!-- Undirected Relationship -->

      

      <!-- Classifier -->

      
        
        


        
        


        
        


        
        


        
        

      

      <!-- Interface -->

      

      <!-- Component -->

      

      <!-- Node -->

      

      <!-- Actor -->

      

      <!-- Use Case -->

      

      <!-- Template Parameters -->

      

      <!-- Literals -->

      

      <!-- Attributes -->

      

      <!-- Operations -->

      
      <section>
        <h3>Operations</h3>
        <table class="table table-striped table-bordered">
          <tr>
            <th>Visibility</th>
            <th>Name</th>
            <th>Description</th>
          </tr>
          
          <tr>
            <td>public</td>
            <td><a href="2a17dc13e1fc93c2c2b4c36207d4966a.html">SwitchPoint()</a></td>
            <td><p>Creates a new switch point.</p></td>
          </tr>
          
          <tr>
            <td>public</td>
            <td><a href="974ee3271584909dd4ed5d096959cb16.html">hasBeenInvalidated(): boolean</a></td>
            <td><p>Determines if this switch point has been invalidated yet.
&lt;p style=&quot;font-size:smaller;&quot;&gt;
&lt;em&gt;Discussion:&lt;/em&gt;
Because of the one-way nature of invalidation, once a switch point begins
to return true for {@code hasBeenInvalidated},
it will always do so in the future.
On the other hand, a valid switch point visible to other threads may
be invalidated at any moment, due to a request by another thread.
&lt;p style=&quot;font-size:smaller;&quot;&gt;
Since invalidation is a global and immediate operation,
the execution of this query, on a valid switchpoint,
must be internally sequenced with any
other threads that could cause invalidation.
This query may therefore be expensive.
The recommended way to build a boolean-valued method handle
which queries the invalidation state of a switch point {@code s} is
to call {@code s.guardWithTest} on
{@link MethodHandles#constant constant} true and false method handles.
@return true if this switch point has been invalidated</p></td>
          </tr>
          
          <tr>
            <td>public</td>
            <td><a href="7ed2677e90473cb31adaa1dfaf9bb4d9.html">guardWithTest(target: MethodHandle, fallback: MethodHandle): MethodHandle</a></td>
            <td><p>Returns a method handle which always delegates either to the target or the fallback.
The method handle will delegate to the target exactly as long as the switch point is valid.
After that, it will permanently delegate to the fallback.
&lt;p&gt;
The target and fallback must be of exactly the same method type,
and the resulting combined method handle will also be of this type.
@param target the method handle selected by the switch point as long as it is valid
@param fallback the method handle selected by the switch point after it is invalidated
@return a combined method handle which always calls either the target or fallback
@throws NullPointerException if either argument is null
@throws IllegalArgumentException if the two method types do not match
@see MethodHandles#guardWithTest</p></td>
          </tr>
          
          <tr>
            <td>public</td>
            <td><a href="985ebe8c81907f0ac168d282d6a277c7.html">invalidateAll(switchPoints: SwitchPoint): void</a></td>
            <td><p>Sets all of the given switch points into the invalid state.
After this call executes, no thread will observe any of the
switch points to be in a valid state.
&lt;p&gt;
This operation is likely to be expensive and should be used sparingly.
If possible, it should be buffered for batch processing on sets of switch points.
&lt;p&gt;
If {@code switchPoints} contains a null element,
a {@code NullPointerException} will be raised.
In this case, some non-null elements in the array may be
processed before the method returns abnormally.
Which elements these are (if any) is implementation-dependent.
&lt;p style=&quot;font-size:smaller;&quot;&gt;
&lt;em&gt;Discussion:&lt;/em&gt;
For performance reasons, {@code invalidateAll} is not a virtual method
on a single switch point, but rather applies to a set of switch points.
Some implementations may incur a large fixed overhead cost
for processing one or more invalidation operations,
but a small incremental cost for each additional invalidation.
In any case, this operation is likely to be costly, since
other threads may have to be somehow interrupted
in order to make them notice the updated switch point state.
However, it may be observed that a single call to invalidate
several switch points has the same formal effect as many calls,
each on just one of the switch points.
&lt;p style=&quot;font-size:smaller;&quot;&gt;
&lt;em&gt;Implementation Note:&lt;/em&gt;
Simple implementations of {@code SwitchPoint} may use
a private {@link MutableCallSite} to publish the state of a switch point.
In such an implementation, the {@code invalidateAll} method can
simply change the call site&#39;s target, and issue one call to
{@linkplain MutableCallSite#syncAll synchronize} all the
private call sites.
@param switchPoints an array of call sites to be synchronized
@throws NullPointerException if the {@code switchPoints} array reference is null
or the array contains a null</p></td>
          </tr>
          
        </table>
      </section>
      

      <!-- Receptions -->

      

      <!-- Extension Points -->

      

      <!-- Parameters -->

      

      <!-- Diagrams -->

      
      

      <!-- Behavior -->

      

      <!-- Action -->

      

      <!-- Interaction -->

      

      <!-- CombinedFragment -->

      

      <!-- Activity -->

      

      <!-- State Machine -->

      

      <!-- State Machine -->

      

      <!-- State -->

      

      <!-- Vertex -->

      

      <!-- Transition -->

      

      <!-- Data Model (ERD) -->

      

      <!-- Columns (ERD) -->

      

      <!-- Related Entities (ERD) -->

      

      <!-- Data Flows (DFD) -->

      

      <!-- Flows (Flowchart) -->

      

      <!-- Properties -->

      <section>
        <h3>Properties</h3>
        
        <table class="table table-striped table-bordered">
    <tr>
        <th width="50%">Name</th>
        <th width="50%">Value</th>
    </tr>
    
    
    
    
    
    
    
    <tr>
        <td>name</td>
        <td>SwitchPoint</td>
    </tr>
    
    
    
    
    
    
    
    
    
    
    
    <tr>
        <td>stereotype</td>
        <td><span class='label label-info'>null</span></td>
    </tr>
    
    
    
    
    
    <tr>
        <td>visibility</td>
        <td>public</td>
    </tr>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <tr>
        <td>isAbstract</td>
        <td><span class='label label-info'>false</span></td>
    </tr>
    
    
    
    
    
    <tr>
        <td>isFinalSpecialization</td>
        <td><span class='label label-info'>false</span></td>
    </tr>
    
    
    
    
    
    <tr>
        <td>isLeaf</td>
        <td><span class='label label-info'>false</span></td>
    </tr>
    
    
    
    
    
    <tr>
        <td>isActive</td>
        <td><span class='label label-info'>false</span></td>
    </tr>
    
    
    
</table>                

      </section>

      <!-- Tags -->

      

      <!-- Constraints, Dependencies, Dependants -->

      
        
        


        
        


        
        

      

      <!-- Relationships -->

      
      
<section class="element-list">
    <h3>Relationships</h3>
    <ul class="nav nav-list">
        
        <li><a href='89cb8b0219b2cf493a095465b9574821.html'><span class='node-icon staruml-icon icon-UMLAssociation'></span>(SwitchPoint—MethodHandle)</a></li>
        
        <li><a href='2c2cd37d7b04d810e5eddca5291be96b.html'><span class='node-icon staruml-icon icon-UMLAssociation'></span>(SwitchPoint—MethodHandle)</a></li>
        
        <li><a href='a10c772e936c1cf3bad1ebf8bde380f6.html'><span class='node-icon staruml-icon icon-UMLAssociation'></span>(SwitchPoint—MutableCallSite)</a></li>
        
        <li><a href='dead0251f886a01ce52f590d12c8d4d8.html'><span class='node-icon staruml-icon icon-UMLAssociation'></span>(SwitchPoint—MethodHandle)</a></li>
        
    </ul>
</section>



      <!-- Owned Elements -->

      
      
<section class="element-list">
    <h3>Owned Elements</h3>
    <ul class="nav nav-list">
        
        <li><a href='89cb8b0219b2cf493a095465b9574821.html'><span class='node-icon staruml-icon icon-UMLAssociation'></span>(SwitchPoint—MethodHandle)</a></li>
        
        <li><a href='2c2cd37d7b04d810e5eddca5291be96b.html'><span class='node-icon staruml-icon icon-UMLAssociation'></span>(SwitchPoint—MethodHandle)</a></li>
        
        <li><a href='a10c772e936c1cf3bad1ebf8bde380f6.html'><span class='node-icon staruml-icon icon-UMLAssociation'></span>(SwitchPoint—MutableCallSite)</a></li>
        
        <li><a href='dead0251f886a01ce52f590d12c8d4d8.html'><span class='node-icon staruml-icon icon-UMLAssociation'></span>(SwitchPoint—MethodHandle)</a></li>
        
    </ul>
</section>



    </div>
  </body>
</html>
