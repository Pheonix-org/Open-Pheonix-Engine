<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>BytecodeStringBuilderStrategy</title>
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,300italic,400italic,700italic|Source+Code+Pro:300,400,700' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="../assets/css/bootstrap.css">
<link rel="stylesheet" href="../assets/css/jquery.bonsai.css">
<link rel="stylesheet" href="../assets/css/main.css">
<link rel="stylesheet" href="../assets/icon-font/icons.css">
<script type="text/javascript" src="../assets/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript" src="../assets/js/bootstrap.js"></script>
<script type="text/javascript" src="../assets/js/jquery.bonsai.js"></script>

  </head>
  <body>
    <div>

      <!-- Name Title -->

      <h1>BytecodeStringBuilderStrategy</h1>

      <!-- Type and Stereotype -->

      <section style="margin-top: .5em;">
        <span class="alert alert-info">
          <span class="node-icon staruml-icon icon-UMLClass"></span>
          UMLClass
        </span>
        
      </section>

      <!-- Path -->

      <section style="margin-top: 10px">
        
        
        
          
          <span class="label label-info"><a href='cf9c8b720f3815adeccaf3ef6e48c6c4.html'><span class='node-icon staruml-icon icon-Project'></span>UML</a></span>
        
          <span>::</span>
          <span class="label label-info"><a href='da2be80fe6e48fd9d101c1429f49bd58.html'><span class='node-icon staruml-icon icon-UMLModel'></span>openJDK</a></span>
        
          <span>::</span>
          <span class="label label-info"><a href='ee78c922cc529ca62752f771c0bb7b9d.html'><span class='node-icon staruml-icon icon-UMLPackage'></span>java</a></span>
        
          <span>::</span>
          <span class="label label-info"><a href='a93b2fc56794e246bf26838d14b54f65.html'><span class='node-icon staruml-icon icon-UMLPackage'></span>lang</a></span>
        
          <span>::</span>
          <span class="label label-info"><a href='e4c701803145d5e3dc249c369d7c56bb.html'><span class='node-icon staruml-icon icon-UMLPackage'></span>invoke</a></span>
        
          <span>::</span>
          <span class="label label-info"><a href='357a0213289b50f9f29ee9ae1b83d026.html'><span class='node-icon staruml-icon icon-UMLClass'></span>StringConcatFactory</a></span>
        
          <span>::</span>
          <span class="label label-info"><a href='c8e2d52dc97e68ef823163e6e29bad4a.html'><span class='node-icon staruml-icon icon-UMLClass'></span>BytecodeStringBuilderStrategy</a></span>
        
      </section>

      <!-- Diagram -->

      

      <!-- Description -->

      
      <section>
        <h3>Description</h3>
        <div>
          
            <p>Bytecode StringBuilder strategy.
&lt;p&gt;This strategy operates in three modes, gated by {@link Mode}.
&lt;p&gt;&lt;b&gt;{@link Strategy#BC<em>SB}: &quot;bytecode StringBuilder&quot;.&lt;/b&gt;
&lt;p&gt;This strategy spins up the bytecode that has the same StringBuilder
chain javac would otherwise emit. This strategy uses only the public API,
and comes as the baseline for the current JDK behavior. On other words,
this strategy moves the javac generated bytecode to runtime. The
generated bytecode is loaded via Unsafe.defineAnonymousClass, but with
the caller class coming from the BSM -- in other words, the protection
guarantees are inherited from the method where invokedynamic was
originally called. This means, among other things, that the bytecode is
verified for all non-JDK uses.
&lt;p&gt;&lt;b&gt;{@link Strategy#BC</em>SB<em>SIZED}: &quot;bytecode StringBuilder, but
sized&quot;.&lt;/b&gt;
&lt;p&gt;This strategy acts similarly to {@link Strategy#BC</em>SB}, but it also
tries to guess the capacity required for StringBuilder to accept all
arguments without resizing. This strategy only makes an educated guess:
it only guesses the space required for known types (e.g. primitives and
Strings), but does not otherwise convert arguments. Therefore, the
capacity estimate may be wrong, and StringBuilder may have to
transparently resize or trim when doing the actual concatenation. While
this does not constitute a correctness issue (in the end, that what BC<em>SB
has to do anyway), this does pose a potential performance problem.
&lt;p&gt;&lt;b&gt;{@link Strategy#BC</em>SB<em>SIZED</em>EXACT}: &quot;bytecode StringBuilder, but
sized exactly&quot;.&lt;/b&gt;
&lt;p&gt;This strategy improves on @link Strategy#BC<em>SB</em>SIZED}, by first
converting all arguments to String in order to get the exact capacity
StringBuilder should have. The conversion is done via the public
String.valueOf and/or Object.toString methods, and does not touch any
private String API.</p>
          
        </div>
      </section>
      

      <!-- Specification -->

      

      <!-- Directed Relationship -->

      

      <!-- Undirected Relationship -->

      

      <!-- Classifier -->

      
        
        


        
        


        
        


        
        


        
        

      

      <!-- Interface -->

      

      <!-- Component -->

      

      <!-- Node -->

      

      <!-- Actor -->

      

      <!-- Use Case -->

      

      <!-- Template Parameters -->

      

      <!-- Literals -->

      

      <!-- Attributes -->

      
      <section>
        <h3>Attributes</h3>
        <table class="table table-striped table-bordered">
          <tr>
            <th>Visibility</th>
            <th>Name</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
          
          <tr>
            <td>package</td>
            <td><a href="dd40cc8ed10b6e982b6e4a6f9826f986.html">UNSAFE</a></td>
            <td><a href='81276da101a962c93f00c426257be596.html'>Unsafe</a></td>
            <td></td>
          </tr>
          
          <tr>
            <td>package</td>
            <td><a href="4f85a49f55b08e4c4886bfee2d7cf302.html">CLASSFILE_VERSION</a></td>
            <td>int</td>
            <td></td>
          </tr>
          
          <tr>
            <td>package</td>
            <td><a href="c29f5087846901d74bd4b2c3092286e5.html">METHOD_NAME</a></td>
            <td>String</td>
            <td></td>
          </tr>
          
        </table>
      </section>
      

      <!-- Operations -->

      
      <section>
        <h3>Operations</h3>
        <table class="table table-striped table-bordered">
          <tr>
            <th>Visibility</th>
            <th>Name</th>
            <th>Description</th>
          </tr>
          
          <tr>
            <td>private</td>
            <td><a href="66ca3bbc1be5864346ffb07e432ce083.html">BytecodeStringBuilderStrategy()</a></td>
            <td></td>
          </tr>
          
          <tr>
            <td>private</td>
            <td><a href="26ada71f850652a92497a356ee5dc1cb.html">generate(lookup: Lookup, className: String, args: MethodType, recipe: Recipe, mode: Mode): MethodHandle</a></td>
            <td></td>
          </tr>
          
          <tr>
            <td>private</td>
            <td><a href="c80eba175687eaae5dfa06398e07acc1.html">dumpIfEnabled(name: String, bytes: byte): void</a></td>
            <td><p>In exact mode, we need to convert all arguments to their String representations,
                    as this allows to compute their String sizes exactly. We cannot use private
                    methods for primitives in here, therefore we need to convert those as well.</p>

<pre><code>                We also record what arguments are guaranteed to be non-null as the result
                of the conversion. String.valueOf does the null checks for us. The only
                corner case to take care of is String.valueOf(Object) returning null itself.

                Also, if any conversion happened, then the slot indices in the incoming
                arguments are not equal to the final local maps. The only case this may break
                is when converting 2-slot long/double argument to 1-slot String. Therefore,
                we get away with tracking modified offset, since no conversion can overwrite
                the upcoming the argument.</code></pre>

<p>When operating in sized mode (this includes exact mode), it makes sense to make
                    StringBuilder append chains look familiar to OptimizeStringConcat. For that, we
                    need to do null-checks early, not make the append chain shape simpler.
Sized mode requires us to walk through the arguments, and estimate the final length.
                    In exact mode, this will operate on Strings only. This code would accumulate the
                    final length on stack.
If an argument is String, then we can call .length() on it. Sized/Exact modes have
                                converted arguments for us. If an argument is primitive, we can provide a guess
                                for its String representation size.
Exactness checks compare the final StringBuilder.capacity() with a resulting
                    String.length(). If these values disagree, that means StringBuilder had to perform
                    storage trimming, which defeats the purpose of exact strategies.
The logic for this check is as follows:</p>

<pre><code>                 Stack before:     Op:
                  (SB)              dup, dup
                  (SB, SB, SB)      capacity()
                  (int, SB, SB)     swap
                  (SB, int, SB)     toString()
                  (S, int, SB)      length()
                  (int, int, SB)    if_icmpeq
                  (SB)              &lt;end&gt;

               Note that it leaves the same StringBuilder on exit, like the one on enter.</code></pre></td>
          </tr>
          
          <tr>
            <td>private</td>
            <td><a href="d82812e4b7c3b9808de13b9cbe6942e5.html">getSBAppendDesc(cl: Class): String</a></td>
            <td></td>
          </tr>
          
          <tr>
            <td>private</td>
            <td><a href="1c7ec391ca5a95228c0ecdd1a3e15b72.html">getStringValueOfDesc(cl: Class): String</a></td>
            <td></td>
          </tr>
          
          <tr>
            <td>private</td>
            <td><a href="5715a72d1c775ae5d85540d88e7eb9a4.html">iconst(mv: MethodVisitor, cst: int): void</a></td>
            <td><p>The following method is copied from
org.objectweb.asm.commons.InstructionAdapter. Part of ASM: a very small
and fast Java bytecode manipulation framework.
Copyright (c) 2000-2005 INRIA, France Telecom All rights reserved.</p></td>
          </tr>
          
          <tr>
            <td>private</td>
            <td><a href="caa1d89af8834718d7eafe3789716f58.html">getLoadOpcode(c: Class): int</a></td>
            <td></td>
          </tr>
          
          <tr>
            <td>private</td>
            <td><a href="12a4ce7f39c7ca3e8a2134c40927ab63.html">getOpcodeOffset(c: Class): int</a></td>
            <td></td>
          </tr>
          
          <tr>
            <td>private</td>
            <td><a href="99693b7970d73e4ac0de121d98df42c4.html">getParameterSize(c: Class): int</a></td>
            <td></td>
          </tr>
          
        </table>
      </section>
      

      <!-- Receptions -->

      

      <!-- Extension Points -->

      

      <!-- Parameters -->

      

      <!-- Diagrams -->

      
      

      <!-- Behavior -->

      

      <!-- Action -->

      

      <!-- Interaction -->

      

      <!-- CombinedFragment -->

      

      <!-- Activity -->

      

      <!-- State Machine -->

      

      <!-- State Machine -->

      

      <!-- State -->

      

      <!-- Vertex -->

      

      <!-- Transition -->

      

      <!-- Data Model (ERD) -->

      

      <!-- Columns (ERD) -->

      

      <!-- Related Entities (ERD) -->

      

      <!-- Data Flows (DFD) -->

      

      <!-- Flows (Flowchart) -->

      

      <!-- Properties -->

      <section>
        <h3>Properties</h3>
        
        <table class="table table-striped table-bordered">
    <tr>
        <th width="50%">Name</th>
        <th width="50%">Value</th>
    </tr>
    
    
    
    
    
    
    
    <tr>
        <td>name</td>
        <td>BytecodeStringBuilderStrategy</td>
    </tr>
    
    
    
    
    
    
    
    
    
    
    
    <tr>
        <td>stereotype</td>
        <td><span class='label label-info'>null</span></td>
    </tr>
    
    
    
    
    
    <tr>
        <td>visibility</td>
        <td>private</td>
    </tr>
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <tr>
        <td>isAbstract</td>
        <td><span class='label label-info'>false</span></td>
    </tr>
    
    
    
    
    
    <tr>
        <td>isFinalSpecialization</td>
        <td><span class='label label-info'>true</span></td>
    </tr>
    
    
    
    
    
    <tr>
        <td>isLeaf</td>
        <td><span class='label label-info'>true</span></td>
    </tr>
    
    
    
    
    
    <tr>
        <td>isActive</td>
        <td><span class='label label-info'>false</span></td>
    </tr>
    
    
    
</table>                

      </section>

      <!-- Tags -->

      

      <!-- Constraints, Dependencies, Dependants -->

      
        
        


        
        


        
        

      

      <!-- Relationships -->

      
      


      <!-- Owned Elements -->

      
      


    </div>
  </body>
</html>
